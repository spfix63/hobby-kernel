#include <cstddef>#include <cstdlib>#include "Console.h"static int is_initialized = 0;static char *start_address;static char *last_valid_address;static char *current_address;struct memory_block{	int is_available;	size_t size;};void init_kernel_malloc(){	start_address = (char *)0x00200000; //2MB	last_valid_address = (char *)0x00300000; //3MB	current_address = start_address;	is_initialized = 1;		struct memory_block *mb = (struct memory_block *)current_address;	mb->is_available = 1;	mb->size = last_valid_address - start_address;}void* kernel_malloc(size_t bytes){	if (!is_initialized)		init_kernel_malloc();	char *ret = NULL;	int cbBlock = sizeof(struct memory_block);	struct memory_block *curr = (struct memory_block *)current_address;	struct memory_block *mb;	do	{		if ((curr->is_available) && (curr->size >= (bytes + cbBlock)))		{			size_t curr_size = curr->size;					mb = curr;			mb->is_available = 0;			mb->size = bytes + cbBlock;						current_address += cbBlock;			ret = current_address;			current_address += bytes;						curr = (struct memory_block *)current_address;			if (curr_size != mb->size)			{					curr->is_available = 1;				curr->size = curr_size - mb->size;			}		}		else		{			curr += curr->size;			if (curr == (struct memory_block *)last_valid_address)			{				curr = (struct memory_block *)start_address;			}		}	} while (!ret && (curr != (struct memory_block *)current_address));	if (!ret)	{		IO::Console::kprintln("malloc dun goofed, need better memory allocator");	}	else	{		// IO::Console::kprint("Memory: malloc for ");		// IO::Console::kprint((int)bytes);		// IO::Console::kprint(" bytes at address ");		// IO::Console::kprinthex((int)ret);		// IO::Console::kprintln();	}	return (void *)ret;}void kernel_free(void *ptr){	//memory_block object lies just before ptr	((struct memory_block *)ptr - 1)->is_available = 1;	// IO::Console::kprint("Memory: free address ");	// IO::Console::kprinthex((int)ptr);	// IO::Console::kprintln();}